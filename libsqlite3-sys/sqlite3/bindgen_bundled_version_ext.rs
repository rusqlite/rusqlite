/* automatically generated by rust-bindgen 0.69.1 */

pub const SQLITE_VERSION: &[u8; 7] = b"3.44.0\0";
pub const SQLITE_VERSION_NUMBER: i32 = 3044000;
pub const SQLITE_SOURCE_ID: &[u8; 85] =
    b"2023-11-01 11:23:50 17129ba1ff7f0daf37100ee82d507aef7827cf38de1866e2633096ae6ad81301\0";
pub const SQLITE_OK: i32 = 0;
pub const SQLITE_ERROR: i32 = 1;
pub const SQLITE_INTERNAL: i32 = 2;
pub const SQLITE_PERM: i32 = 3;
pub const SQLITE_ABORT: i32 = 4;
pub const SQLITE_BUSY: i32 = 5;
pub const SQLITE_LOCKED: i32 = 6;
pub const SQLITE_NOMEM: i32 = 7;
pub const SQLITE_READONLY: i32 = 8;
pub const SQLITE_INTERRUPT: i32 = 9;
pub const SQLITE_IOERR: i32 = 10;
pub const SQLITE_CORRUPT: i32 = 11;
pub const SQLITE_NOTFOUND: i32 = 12;
pub const SQLITE_FULL: i32 = 13;
pub const SQLITE_CANTOPEN: i32 = 14;
pub const SQLITE_PROTOCOL: i32 = 15;
pub const SQLITE_EMPTY: i32 = 16;
pub const SQLITE_SCHEMA: i32 = 17;
pub const SQLITE_TOOBIG: i32 = 18;
pub const SQLITE_CONSTRAINT: i32 = 19;
pub const SQLITE_MISMATCH: i32 = 20;
pub const SQLITE_MISUSE: i32 = 21;
pub const SQLITE_NOLFS: i32 = 22;
pub const SQLITE_AUTH: i32 = 23;
pub const SQLITE_FORMAT: i32 = 24;
pub const SQLITE_RANGE: i32 = 25;
pub const SQLITE_NOTADB: i32 = 26;
pub const SQLITE_NOTICE: i32 = 27;
pub const SQLITE_WARNING: i32 = 28;
pub const SQLITE_ROW: i32 = 100;
pub const SQLITE_DONE: i32 = 101;
pub const SQLITE_ERROR_MISSING_COLLSEQ: i32 = 257;
pub const SQLITE_ERROR_RETRY: i32 = 513;
pub const SQLITE_ERROR_SNAPSHOT: i32 = 769;
pub const SQLITE_IOERR_READ: i32 = 266;
pub const SQLITE_IOERR_SHORT_READ: i32 = 522;
pub const SQLITE_IOERR_WRITE: i32 = 778;
pub const SQLITE_IOERR_FSYNC: i32 = 1034;
pub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;
pub const SQLITE_IOERR_TRUNCATE: i32 = 1546;
pub const SQLITE_IOERR_FSTAT: i32 = 1802;
pub const SQLITE_IOERR_UNLOCK: i32 = 2058;
pub const SQLITE_IOERR_RDLOCK: i32 = 2314;
pub const SQLITE_IOERR_DELETE: i32 = 2570;
pub const SQLITE_IOERR_BLOCKED: i32 = 2826;
pub const SQLITE_IOERR_NOMEM: i32 = 3082;
pub const SQLITE_IOERR_ACCESS: i32 = 3338;
pub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;
pub const SQLITE_IOERR_LOCK: i32 = 3850;
pub const SQLITE_IOERR_CLOSE: i32 = 4106;
pub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;
pub const SQLITE_IOERR_SHMOPEN: i32 = 4618;
pub const SQLITE_IOERR_SHMSIZE: i32 = 4874;
pub const SQLITE_IOERR_SHMLOCK: i32 = 5130;
pub const SQLITE_IOERR_SHMMAP: i32 = 5386;
pub const SQLITE_IOERR_SEEK: i32 = 5642;
pub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;
pub const SQLITE_IOERR_MMAP: i32 = 6154;
pub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;
pub const SQLITE_IOERR_CONVPATH: i32 = 6666;
pub const SQLITE_IOERR_VNODE: i32 = 6922;
pub const SQLITE_IOERR_AUTH: i32 = 7178;
pub const SQLITE_IOERR_BEGIN_ATOMIC: i32 = 7434;
pub const SQLITE_IOERR_COMMIT_ATOMIC: i32 = 7690;
pub const SQLITE_IOERR_ROLLBACK_ATOMIC: i32 = 7946;
pub const SQLITE_IOERR_DATA: i32 = 8202;
pub const SQLITE_IOERR_CORRUPTFS: i32 = 8458;
pub const SQLITE_IOERR_IN_PAGE: i32 = 8714;
pub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;
pub const SQLITE_LOCKED_VTAB: i32 = 518;
pub const SQLITE_BUSY_RECOVERY: i32 = 261;
pub const SQLITE_BUSY_SNAPSHOT: i32 = 517;
pub const SQLITE_BUSY_TIMEOUT: i32 = 773;
pub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;
pub const SQLITE_CANTOPEN_ISDIR: i32 = 526;
pub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;
pub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;
pub const SQLITE_CANTOPEN_DIRTYWAL: i32 = 1294;
pub const SQLITE_CANTOPEN_SYMLINK: i32 = 1550;
pub const SQLITE_CORRUPT_VTAB: i32 = 267;
pub const SQLITE_CORRUPT_SEQUENCE: i32 = 523;
pub const SQLITE_CORRUPT_INDEX: i32 = 779;
pub const SQLITE_READONLY_RECOVERY: i32 = 264;
pub const SQLITE_READONLY_CANTLOCK: i32 = 520;
pub const SQLITE_READONLY_ROLLBACK: i32 = 776;
pub const SQLITE_READONLY_DBMOVED: i32 = 1032;
pub const SQLITE_READONLY_CANTINIT: i32 = 1288;
pub const SQLITE_READONLY_DIRECTORY: i32 = 1544;
pub const SQLITE_ABORT_ROLLBACK: i32 = 516;
pub const SQLITE_CONSTRAINT_CHECK: i32 = 275;
pub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;
pub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;
pub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;
pub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;
pub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;
pub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;
pub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;
pub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;
pub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;
pub const SQLITE_CONSTRAINT_PINNED: i32 = 2835;
pub const SQLITE_CONSTRAINT_DATATYPE: i32 = 3091;
pub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;
pub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;
pub const SQLITE_NOTICE_RBU: i32 = 795;
pub const SQLITE_WARNING_AUTOINDEX: i32 = 284;
pub const SQLITE_AUTH_USER: i32 = 279;
pub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;
pub const SQLITE_OK_SYMLINK: i32 = 512;
pub const SQLITE_OPEN_READONLY: i32 = 1;
pub const SQLITE_OPEN_READWRITE: i32 = 2;
pub const SQLITE_OPEN_CREATE: i32 = 4;
pub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;
pub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;
pub const SQLITE_OPEN_AUTOPROXY: i32 = 32;
pub const SQLITE_OPEN_URI: i32 = 64;
pub const SQLITE_OPEN_MEMORY: i32 = 128;
pub const SQLITE_OPEN_MAIN_DB: i32 = 256;
pub const SQLITE_OPEN_TEMP_DB: i32 = 512;
pub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;
pub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;
pub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;
pub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;
pub const SQLITE_OPEN_SUPER_JOURNAL: i32 = 16384;
pub const SQLITE_OPEN_NOMUTEX: i32 = 32768;
pub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;
pub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;
pub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;
pub const SQLITE_OPEN_WAL: i32 = 524288;
pub const SQLITE_OPEN_NOFOLLOW: i32 = 16777216;
pub const SQLITE_OPEN_EXRESCODE: i32 = 33554432;
pub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;
pub const SQLITE_IOCAP_ATOMIC: i32 = 1;
pub const SQLITE_IOCAP_ATOMIC512: i32 = 2;
pub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;
pub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;
pub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;
pub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;
pub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;
pub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;
pub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;
pub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;
pub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;
pub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;
pub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;
pub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;
pub const SQLITE_IOCAP_BATCH_ATOMIC: i32 = 16384;
pub const SQLITE_LOCK_NONE: i32 = 0;
pub const SQLITE_LOCK_SHARED: i32 = 1;
pub const SQLITE_LOCK_RESERVED: i32 = 2;
pub const SQLITE_LOCK_PENDING: i32 = 3;
pub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;
pub const SQLITE_SYNC_NORMAL: i32 = 2;
pub const SQLITE_SYNC_FULL: i32 = 3;
pub const SQLITE_SYNC_DATAONLY: i32 = 16;
pub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;
pub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;
pub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;
pub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;
pub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;
pub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;
pub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;
pub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;
pub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;
pub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;
pub const SQLITE_FCNTL_OVERWRITE: i32 = 11;
pub const SQLITE_FCNTL_VFSNAME: i32 = 12;
pub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;
pub const SQLITE_FCNTL_PRAGMA: i32 = 14;
pub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;
pub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;
pub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;
pub const SQLITE_FCNTL_TRACE: i32 = 19;
pub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;
pub const SQLITE_FCNTL_SYNC: i32 = 21;
pub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;
pub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;
pub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;
pub const SQLITE_FCNTL_ZIPVFS: i32 = 25;
pub const SQLITE_FCNTL_RBU: i32 = 26;
pub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;
pub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;
pub const SQLITE_FCNTL_WIN32_GET_HANDLE: i32 = 29;
pub const SQLITE_FCNTL_PDB: i32 = 30;
pub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: i32 = 31;
pub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: i32 = 32;
pub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: i32 = 33;
pub const SQLITE_FCNTL_LOCK_TIMEOUT: i32 = 34;
pub const SQLITE_FCNTL_DATA_VERSION: i32 = 35;
pub const SQLITE_FCNTL_SIZE_LIMIT: i32 = 36;
pub const SQLITE_FCNTL_CKPT_DONE: i32 = 37;
pub const SQLITE_FCNTL_RESERVE_BYTES: i32 = 38;
pub const SQLITE_FCNTL_CKPT_START: i32 = 39;
pub const SQLITE_FCNTL_EXTERNAL_READER: i32 = 40;
pub const SQLITE_FCNTL_CKSM_FILE: i32 = 41;
pub const SQLITE_FCNTL_RESET_CACHE: i32 = 42;
pub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;
pub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;
pub const SQLITE_LAST_ERRNO: i32 = 4;
pub const SQLITE_ACCESS_EXISTS: i32 = 0;
pub const SQLITE_ACCESS_READWRITE: i32 = 1;
pub const SQLITE_ACCESS_READ: i32 = 2;
pub const SQLITE_SHM_UNLOCK: i32 = 1;
pub const SQLITE_SHM_LOCK: i32 = 2;
pub const SQLITE_SHM_SHARED: i32 = 4;
pub const SQLITE_SHM_EXCLUSIVE: i32 = 8;
pub const SQLITE_SHM_NLOCK: i32 = 8;
pub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;
pub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;
pub const SQLITE_CONFIG_SERIALIZED: i32 = 3;
pub const SQLITE_CONFIG_MALLOC: i32 = 4;
pub const SQLITE_CONFIG_GETMALLOC: i32 = 5;
pub const SQLITE_CONFIG_SCRATCH: i32 = 6;
pub const SQLITE_CONFIG_PAGECACHE: i32 = 7;
pub const SQLITE_CONFIG_HEAP: i32 = 8;
pub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;
pub const SQLITE_CONFIG_MUTEX: i32 = 10;
pub const SQLITE_CONFIG_GETMUTEX: i32 = 11;
pub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;
pub const SQLITE_CONFIG_PCACHE: i32 = 14;
pub const SQLITE_CONFIG_GETPCACHE: i32 = 15;
pub const SQLITE_CONFIG_LOG: i32 = 16;
pub const SQLITE_CONFIG_URI: i32 = 17;
pub const SQLITE_CONFIG_PCACHE2: i32 = 18;
pub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;
pub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;
pub const SQLITE_CONFIG_SQLLOG: i32 = 21;
pub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;
pub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;
pub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;
pub const SQLITE_CONFIG_PMASZ: i32 = 25;
pub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;
pub const SQLITE_CONFIG_SMALL_MALLOC: i32 = 27;
pub const SQLITE_CONFIG_SORTERREF_SIZE: i32 = 28;
pub const SQLITE_CONFIG_MEMDB_MAXSIZE: i32 = 29;
pub const SQLITE_DBCONFIG_MAINDBNAME: i32 = 1000;
pub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;
pub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;
pub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;
pub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;
pub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;
pub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: i32 = 1006;
pub const SQLITE_DBCONFIG_ENABLE_QPSG: i32 = 1007;
pub const SQLITE_DBCONFIG_TRIGGER_EQP: i32 = 1008;
pub const SQLITE_DBCONFIG_RESET_DATABASE: i32 = 1009;
pub const SQLITE_DBCONFIG_DEFENSIVE: i32 = 1010;
pub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: i32 = 1011;
pub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: i32 = 1012;
pub const SQLITE_DBCONFIG_DQS_DML: i32 = 1013;
pub const SQLITE_DBCONFIG_DQS_DDL: i32 = 1014;
pub const SQLITE_DBCONFIG_ENABLE_VIEW: i32 = 1015;
pub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: i32 = 1016;
pub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: i32 = 1017;
pub const SQLITE_DBCONFIG_STMT_SCANSTATUS: i32 = 1018;
pub const SQLITE_DBCONFIG_REVERSE_SCANORDER: i32 = 1019;
pub const SQLITE_DBCONFIG_MAX: i32 = 1019;
pub const SQLITE_DENY: i32 = 1;
pub const SQLITE_IGNORE: i32 = 2;
pub const SQLITE_CREATE_INDEX: i32 = 1;
pub const SQLITE_CREATE_TABLE: i32 = 2;
pub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;
pub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;
pub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;
pub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;
pub const SQLITE_CREATE_TRIGGER: i32 = 7;
pub const SQLITE_CREATE_VIEW: i32 = 8;
pub const SQLITE_DELETE: i32 = 9;
pub const SQLITE_DROP_INDEX: i32 = 10;
pub const SQLITE_DROP_TABLE: i32 = 11;
pub const SQLITE_DROP_TEMP_INDEX: i32 = 12;
pub const SQLITE_DROP_TEMP_TABLE: i32 = 13;
pub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;
pub const SQLITE_DROP_TEMP_VIEW: i32 = 15;
pub const SQLITE_DROP_TRIGGER: i32 = 16;
pub const SQLITE_DROP_VIEW: i32 = 17;
pub const SQLITE_INSERT: i32 = 18;
pub const SQLITE_PRAGMA: i32 = 19;
pub const SQLITE_READ: i32 = 20;
pub const SQLITE_SELECT: i32 = 21;
pub const SQLITE_TRANSACTION: i32 = 22;
pub const SQLITE_UPDATE: i32 = 23;
pub const SQLITE_ATTACH: i32 = 24;
pub const SQLITE_DETACH: i32 = 25;
pub const SQLITE_ALTER_TABLE: i32 = 26;
pub const SQLITE_REINDEX: i32 = 27;
pub const SQLITE_ANALYZE: i32 = 28;
pub const SQLITE_CREATE_VTABLE: i32 = 29;
pub const SQLITE_DROP_VTABLE: i32 = 30;
pub const SQLITE_FUNCTION: i32 = 31;
pub const SQLITE_SAVEPOINT: i32 = 32;
pub const SQLITE_COPY: i32 = 0;
pub const SQLITE_RECURSIVE: i32 = 33;
pub const SQLITE_TRACE_STMT: i32 = 1;
pub const SQLITE_TRACE_PROFILE: i32 = 2;
pub const SQLITE_TRACE_ROW: i32 = 4;
pub const SQLITE_TRACE_CLOSE: i32 = 8;
pub const SQLITE_LIMIT_LENGTH: i32 = 0;
pub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;
pub const SQLITE_LIMIT_COLUMN: i32 = 2;
pub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;
pub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;
pub const SQLITE_LIMIT_VDBE_OP: i32 = 5;
pub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;
pub const SQLITE_LIMIT_ATTACHED: i32 = 7;
pub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;
pub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;
pub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;
pub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;
pub const SQLITE_PREPARE_PERSISTENT: ::std::os::raw::c_uint = 1;
pub const SQLITE_PREPARE_NORMALIZE: ::std::os::raw::c_uint = 2;
pub const SQLITE_PREPARE_NO_VTAB: ::std::os::raw::c_uint = 4;
pub const SQLITE_INTEGER: i32 = 1;
pub const SQLITE_FLOAT: i32 = 2;
pub const SQLITE_BLOB: i32 = 4;
pub const SQLITE_NULL: i32 = 5;
pub const SQLITE_TEXT: i32 = 3;
pub const SQLITE3_TEXT: i32 = 3;
pub const SQLITE_UTF8: i32 = 1;
pub const SQLITE_UTF16LE: i32 = 2;
pub const SQLITE_UTF16BE: i32 = 3;
pub const SQLITE_UTF16: i32 = 4;
pub const SQLITE_ANY: i32 = 5;
pub const SQLITE_UTF16_ALIGNED: i32 = 8;
pub const SQLITE_DETERMINISTIC: i32 = 2048;
pub const SQLITE_DIRECTONLY: i32 = 524288;
pub const SQLITE_SUBTYPE: i32 = 1048576;
pub const SQLITE_INNOCUOUS: i32 = 2097152;
pub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: i32 = 1;
pub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: i32 = 2;
pub const SQLITE_TXN_NONE: i32 = 0;
pub const SQLITE_TXN_READ: i32 = 1;
pub const SQLITE_TXN_WRITE: i32 = 2;
pub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;
pub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;
pub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;
pub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;
pub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;
pub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;
pub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;
pub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;
pub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;
pub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;
pub const SQLITE_INDEX_CONSTRAINT_NE: i32 = 68;
pub const SQLITE_INDEX_CONSTRAINT_ISNOT: i32 = 69;
pub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: i32 = 70;
pub const SQLITE_INDEX_CONSTRAINT_ISNULL: i32 = 71;
pub const SQLITE_INDEX_CONSTRAINT_IS: i32 = 72;
pub const SQLITE_INDEX_CONSTRAINT_LIMIT: i32 = 73;
pub const SQLITE_INDEX_CONSTRAINT_OFFSET: i32 = 74;
pub const SQLITE_INDEX_CONSTRAINT_FUNCTION: i32 = 150;
pub const SQLITE_MUTEX_FAST: i32 = 0;
pub const SQLITE_MUTEX_RECURSIVE: i32 = 1;
pub const SQLITE_MUTEX_STATIC_MAIN: i32 = 2;
pub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;
pub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;
pub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;
pub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;
pub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;
pub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;
pub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;
pub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;
pub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;
pub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;
pub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;
pub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;
pub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;
pub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;
pub const SQLITE_TESTCTRL_FIRST: i32 = 5;
pub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;
pub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;
pub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;
pub const SQLITE_TESTCTRL_FK_NO_ACTION: i32 = 7;
pub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;
pub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;
pub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;
pub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;
pub const SQLITE_TESTCTRL_ASSERT: i32 = 12;
pub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;
pub const SQLITE_TESTCTRL_RESERVE: i32 = 14;
pub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;
pub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;
pub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;
pub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: i32 = 17;
pub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;
pub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;
pub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: i32 = 19;
pub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;
pub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;
pub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;
pub const SQLITE_TESTCTRL_ISINIT: i32 = 23;
pub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;
pub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;
pub const SQLITE_TESTCTRL_PARSER_COVERAGE: i32 = 26;
pub const SQLITE_TESTCTRL_RESULT_INTREAL: i32 = 27;
pub const SQLITE_TESTCTRL_PRNG_SEED: i32 = 28;
pub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: i32 = 29;
pub const SQLITE_TESTCTRL_SEEK_COUNT: i32 = 30;
pub const SQLITE_TESTCTRL_TRACEFLAGS: i32 = 31;
pub const SQLITE_TESTCTRL_TUNE: i32 = 32;
pub const SQLITE_TESTCTRL_LOGEST: i32 = 33;
pub const SQLITE_TESTCTRL_USELONGDOUBLE: i32 = 34;
pub const SQLITE_TESTCTRL_LAST: i32 = 34;
pub const SQLITE_STATUS_MEMORY_USED: i32 = 0;
pub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;
pub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;
pub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;
pub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;
pub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;
pub const SQLITE_STATUS_PARSER_STACK: i32 = 6;
pub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;
pub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;
pub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;
pub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;
pub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;
pub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;
pub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;
pub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;
pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;
pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;
pub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;
pub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;
pub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;
pub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;
pub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;
pub const SQLITE_DBSTATUS_CACHE_SPILL: i32 = 12;
pub const SQLITE_DBSTATUS_MAX: i32 = 12;
pub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;
pub const SQLITE_STMTSTATUS_SORT: i32 = 2;
pub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;
pub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;
pub const SQLITE_STMTSTATUS_REPREPARE: i32 = 5;
pub const SQLITE_STMTSTATUS_RUN: i32 = 6;
pub const SQLITE_STMTSTATUS_FILTER_MISS: i32 = 7;
pub const SQLITE_STMTSTATUS_FILTER_HIT: i32 = 8;
pub const SQLITE_STMTSTATUS_MEMUSED: i32 = 99;
pub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;
pub const SQLITE_CHECKPOINT_FULL: i32 = 1;
pub const SQLITE_CHECKPOINT_RESTART: i32 = 2;
pub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;
pub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;
pub const SQLITE_VTAB_INNOCUOUS: i32 = 2;
pub const SQLITE_VTAB_DIRECTONLY: i32 = 3;
pub const SQLITE_VTAB_USES_ALL_SCHEMAS: i32 = 4;
pub const SQLITE_ROLLBACK: i32 = 1;
pub const SQLITE_FAIL: i32 = 3;
pub const SQLITE_REPLACE: i32 = 5;
pub const SQLITE_SCANSTAT_NLOOP: i32 = 0;
pub const SQLITE_SCANSTAT_NVISIT: i32 = 1;
pub const SQLITE_SCANSTAT_EST: i32 = 2;
pub const SQLITE_SCANSTAT_NAME: i32 = 3;
pub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;
pub const SQLITE_SCANSTAT_SELECTID: i32 = 5;
pub const SQLITE_SCANSTAT_PARENTID: i32 = 6;
pub const SQLITE_SCANSTAT_NCYCLE: i32 = 7;
pub const SQLITE_SCANSTAT_COMPLEX: i32 = 1;
pub const SQLITE_SERIALIZE_NOCOPY: ::std::os::raw::c_uint = 1;
pub const SQLITE_DESERIALIZE_FREEONCLOSE: ::std::os::raw::c_uint = 1;
pub const SQLITE_DESERIALIZE_RESIZEABLE: ::std::os::raw::c_uint = 2;
pub const SQLITE_DESERIALIZE_READONLY: ::std::os::raw::c_uint = 4;
pub const NOT_WITHIN: i32 = 0;
pub const PARTLY_WITHIN: i32 = 1;
pub const FULLY_WITHIN: i32 = 2;
pub const FTS5_TOKENIZE_QUERY: i32 = 1;
pub const FTS5_TOKENIZE_PREFIX: i32 = 2;
pub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;
pub const FTS5_TOKENIZE_AUX: i32 = 8;
pub const FTS5_TOKEN_COLOCATED: i32 = 1;
extern "C" {
    pub static sqlite3_version: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3 {
    _unused: [u8; 0],
}
pub type sqlite_int64 = ::std::os::raw::c_longlong;
pub type sqlite_uint64 = ::std::os::raw::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
pub type sqlite3_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_io_methods {
    pub iVersion: ::std::os::raw::c_int,
    pub xClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: *mut ::std::os::raw::c_void,
            iAmt: ::std::os::raw::c_int,
            iOfst: sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: *const ::std::os::raw::c_void,
            iAmt: ::std::os::raw::c_int,
            iOfst: sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -> ::std::os::raw::c_int,
    >,
    pub xSync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFileSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            pSize: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUnlock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCheckReservedLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            pResOut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFileControl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            op: ::std::os::raw::c_int,
            pArg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSectorSize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xDeviceCharacteristics: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xShmMap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iPg: ::std::os::raw::c_int,
            pgsz: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShmLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            offset: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShmBarrier: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_file)>,
    pub xShmUnmap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            deleteFlag: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iOfst: sqlite3_int64,
            iAmt: ::std::os::raw::c_int,
            pp: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUnfetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iOfst: sqlite3_int64,
            p: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mutex {
    _unused: [u8; 0],
}
pub type sqlite3_filename = *const ::std::os::raw::c_char;
pub type sqlite3_syscall_ptr = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vfs {
    pub iVersion: ::std::os::raw::c_int,
    pub szOsFile: ::std::os::raw::c_int,
    pub mxPathname: ::std::os::raw::c_int,
    pub pNext: *mut sqlite3_vfs,
    pub zName: *const ::std::os::raw::c_char,
    pub pAppData: *mut ::std::os::raw::c_void,
    pub xOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: sqlite3_filename,
            arg2: *mut sqlite3_file,
            flags: ::std::os::raw::c_int,
            pOutFlags: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDelete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            syncDir: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xAccess: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            pResOut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFullPathname: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            nOut: ::std::os::raw::c_int,
            zOut: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDlOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zFilename: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xDlError: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            nByte: ::std::os::raw::c_int,
            zErrMsg: *mut ::std::os::raw::c_char,
        ),
    >,
    pub xDlSym: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: *mut ::std::os::raw::c_void,
            zSymbol: *const ::std::os::raw::c_char,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_vfs,
                arg2: *mut ::std::os::raw::c_void,
                zSymbol: *const ::std::os::raw::c_char,
            ),
        >,
    >,
    pub xDlClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::std::os::raw::c_void),
    >,
    pub xRandomness: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            nByte: ::std::os::raw::c_int,
            zOut: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSleep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            microseconds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCurrentTime: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -> ::std::os::raw::c_int,
    >,
    pub xGetLastError: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCurrentTimeInt64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSetSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            arg2: sqlite3_syscall_ptr,
        ) -> ::std::os::raw::c_int,
    >,
    pub xGetSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
        ) -> sqlite3_syscall_ptr,
    >,
    pub xNextSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mem_methods {
    pub xMalloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,
    >,
    pub xFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xRealloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xSize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xRoundup: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub pAppData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_stmt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_context {
    _unused: [u8; 0],
}
pub type sqlite3_destructor_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut sqlite3_temp_directory: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut sqlite3_data_directory: *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_module {
    pub iVersion: ::std::os::raw::c_int,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            pAux: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
            ppVTab: *mut *mut sqlite3_vtab,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xConnect: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            pAux: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
            ppVTab: *mut *mut sqlite3_vtab,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xBestIndex: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: *mut sqlite3_index_info,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDisconnect: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xDestroy: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xOpen: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            ppCursor: *mut *mut sqlite3_vtab_cursor,
        ) -> ::std::os::raw::c_int,
    >,
    pub xClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xFilter: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            idxNum: ::std::os::raw::c_int,
            idxStr: *const ::std::os::raw::c_char,
            argc: ::std::os::raw::c_int,
            argv: *mut *mut sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub xNext: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xEof: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            arg2: *mut sqlite3_context,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRowid: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            pRowid: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUpdate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
            arg4: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xBegin: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xSync: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xCommit: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xRollback: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xFindFunction: ::std::option::Option<
        unsafe extern "C" fn(
            pVtab: *mut sqlite3_vtab,
            nArg: ::std::os::raw::c_int,
            zName: *const ::std::os::raw::c_char,
            pxFunc: *mut ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            ppArg: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRename: ::std::option::Option<
        unsafe extern "C" fn(
            pVtab: *mut sqlite3_vtab,
            zNew: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSavepoint: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRelease: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRollbackTo: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShadowName: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub xIntegrity: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            zSchema: *const ::std::os::raw::c_char,
            zTabName: *const ::std::os::raw::c_char,
            mFlags: ::std::os::raw::c_int,
            pzErr: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_info {
    pub nConstraint: ::std::os::raw::c_int,
    pub aConstraint: *mut sqlite3_index_constraint,
    pub nOrderBy: ::std::os::raw::c_int,
    pub aOrderBy: *mut sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
    pub idxNum: ::std::os::raw::c_int,
    pub idxStr: *mut ::std::os::raw::c_char,
    pub needToFreeIdxStr: ::std::os::raw::c_int,
    pub orderByConsumed: ::std::os::raw::c_int,
    pub estimatedCost: f64,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: ::std::os::raw::c_int,
    pub colUsed: sqlite3_uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_constraint {
    pub iColumn: ::std::os::raw::c_int,
    pub op: ::std::os::raw::c_uchar,
    pub usable: ::std::os::raw::c_uchar,
    pub iTermOffset: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_orderby {
    pub iColumn: ::std::os::raw::c_int,
    pub desc: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_constraint_usage {
    pub argvIndex: ::std::os::raw::c_int,
    pub omit: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: ::std::os::raw::c_int,
    pub zErrMsg: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_blob {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mutex_methods {
    pub xMutexInit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub xMutexEnd: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub xMutexAlloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex,
    >,
    pub xMutexFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexEnter: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexTry: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
    pub xMutexLeave: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexHeld: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
    pub xMutexNotheld: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_str {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_page {
    pub pBuf: *mut ::std::os::raw::c_void,
    pub pExtra: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_methods2 {
    pub iVersion: ::std::os::raw::c_int,
    pub pArg: *mut ::std::os::raw::c_void,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            szPage: ::std::os::raw::c_int,
            szExtra: ::std::os::raw::c_int,
            bPurgeable: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache,
    >,
    pub xCachesize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),
    >,
    pub xPagecount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            key: ::std::os::raw::c_uint,
            createFlag: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache_page,
    >,
    pub xUnpin: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut sqlite3_pcache_page,
            discard: ::std::os::raw::c_int,
        ),
    >,
    pub xRekey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut sqlite3_pcache_page,
            oldKey: ::std::os::raw::c_uint,
            newKey: ::std::os::raw::c_uint,
        ),
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),
    >,
    pub xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
    pub xShrink: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_methods {
    pub pArg: *mut ::std::os::raw::c_void,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            szPage: ::std::os::raw::c_int,
            bPurgeable: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache,
    >,
    pub xCachesize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),
    >,
    pub xPagecount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            key: ::std::os::raw::c_uint,
            createFlag: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xUnpin: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut ::std::os::raw::c_void,
            discard: ::std::os::raw::c_int,
        ),
    >,
    pub xRekey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut ::std::os::raw::c_void,
            oldKey: ::std::os::raw::c_uint,
            newKey: ::std::os::raw::c_uint,
        ),
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),
    >,
    pub xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_backup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_snapshot {
    pub hidden: [::std::os::raw::c_uchar; 48usize],
}
pub type sqlite3_rtree_dbl = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_rtree_geometry {
    pub pContext: *mut ::std::os::raw::c_void,
    pub nParam: ::std::os::raw::c_int,
    pub aParam: *mut sqlite3_rtree_dbl,
    pub pUser: *mut ::std::os::raw::c_void,
    pub xDelUser: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_rtree_query_info {
    pub pContext: *mut ::std::os::raw::c_void,
    pub nParam: ::std::os::raw::c_int,
    pub aParam: *mut sqlite3_rtree_dbl,
    pub pUser: *mut ::std::os::raw::c_void,
    pub xDelUser: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub aCoord: *mut sqlite3_rtree_dbl,
    pub anQueue: *mut ::std::os::raw::c_uint,
    pub nCoord: ::std::os::raw::c_int,
    pub iLevel: ::std::os::raw::c_int,
    pub mxLevel: ::std::os::raw::c_int,
    pub iRowid: sqlite3_int64,
    pub rParentScore: sqlite3_rtree_dbl,
    pub eParentWithin: ::std::os::raw::c_int,
    pub eWithin: ::std::os::raw::c_int,
    pub rScore: sqlite3_rtree_dbl,
    pub apSqlParam: *mut *mut sqlite3_value,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5Context {
    _unused: [u8; 0],
}
pub type fts5_extension_function = ::std::option::Option<
    unsafe extern "C" fn(
        pApi: *const Fts5ExtensionApi,
        pFts: *mut Fts5Context,
        pCtx: *mut sqlite3_context,
        nVal: ::std::os::raw::c_int,
        apVal: *mut *mut sqlite3_value,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5PhraseIter {
    pub a: *const ::std::os::raw::c_uchar,
    pub b: *const ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5ExtensionApi {
    pub iVersion: ::std::os::raw::c_int,
    pub xUserData: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> *mut ::std::os::raw::c_void,
    >,
    pub xColumnCount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,
    >,
    pub xRowCount: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pnRow: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xColumnTotalSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pnToken: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xTokenize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pText: *const ::std::os::raw::c_char,
            nText: ::std::os::raw::c_int,
            pCtx: *mut ::std::os::raw::c_void,
            xToken: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: ::std::os::raw::c_int,
                    arg5: ::std::os::raw::c_int,
                    arg6: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseCount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,
    >,
    pub xPhraseSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xInstCount: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pnInst: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xInst: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iIdx: ::std::os::raw::c_int,
            piPhrase: *mut ::std::os::raw::c_int,
            piCol: *mut ::std::os::raw::c_int,
            piOff: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRowid:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Context) -> sqlite3_int64>,
    pub xColumnText: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pz: *mut *const ::std::os::raw::c_char,
            pn: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xColumnSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pnToken: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xQueryPhrase: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            pUserData: *mut ::std::os::raw::c_void,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const Fts5ExtensionApi,
                    arg2: *mut Fts5Context,
                    arg3: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSetAuxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pAux: *mut ::std::os::raw::c_void,
            xDelete: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub xGetAuxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            bClear: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xPhraseFirst: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            arg2: *mut Fts5PhraseIter,
            arg3: *mut ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseNext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            arg2: *mut Fts5PhraseIter,
            piCol: *mut ::std::os::raw::c_int,
            piOff: *mut ::std::os::raw::c_int,
        ),
    >,
    pub xPhraseFirstColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            arg2: *mut Fts5PhraseIter,
            arg3: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseNextColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            arg2: *mut Fts5PhraseIter,
            piCol: *mut ::std::os::raw::c_int,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5Tokenizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fts5_tokenizer {
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            azArg: *mut *const ::std::os::raw::c_char,
            nArg: ::std::os::raw::c_int,
            ppOut: *mut *mut Fts5Tokenizer,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDelete: ::std::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Tokenizer)>,
    pub xTokenize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Tokenizer,
            pCtx: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
            pText: *const ::std::os::raw::c_char,
            nText: ::std::os::raw::c_int,
            xToken: ::std::option::Option<
                unsafe extern "C" fn(
                    pCtx: *mut ::std::os::raw::c_void,
                    tflags: ::std::os::raw::c_int,
                    pToken: *const ::std::os::raw::c_char,
                    nToken: ::std::os::raw::c_int,
                    iStart: ::std::os::raw::c_int,
                    iEnd: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fts5_api {
    pub iVersion: ::std::os::raw::c_int,
    pub xCreateTokenizer: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            pUserData: *mut ::std::os::raw::c_void,
            pTokenizer: *mut fts5_tokenizer,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFindTokenizer: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            ppUserData: *mut *mut ::std::os::raw::c_void,
            pTokenizer: *mut fts5_tokenizer,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCreateFunction: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            pUserData: *mut ::std::os::raw::c_void,
            xFunction: fts5_extension_function,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_api_routines {
    pub aggregate_context: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            nBytes: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub aggregate_count: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int,
    >,
    pub bind_blob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            n: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_double: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: f64,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_int: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_int64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: sqlite_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_null: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_parameter_count: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub bind_parameter_index: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            zName: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_parameter_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub bind_text: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            n: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_text16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_int,
            arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_value: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub busy_handler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub busy_timeout: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            ms: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub changes:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub collation_needed: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *mut ::std::os::raw::c_void,
            arg3: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut sqlite3,
                    eTextRep: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                ),
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub collation_needed16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *mut ::std::os::raw::c_void,
            arg3: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut sqlite3,
                    eTextRep: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_void,
                ),
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub column_blob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub column_bytes16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub column_count: ::std::option::Option<
        unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub column_database_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub column_database_name16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_decltype: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            i: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub column_decltype16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_double: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -> f64,
    >,
    pub column_int: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub column_int64: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -> sqlite_int64,
    >,
    pub column_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub column_name16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_origin_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub column_origin_name16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_table_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub column_table_name16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_text: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_uchar,
    >,
    pub column_text16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub column_type: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub column_value: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            iCol: ::std::os::raw::c_int,
        ) -> *mut sqlite3_value,
    >,
    pub commit_hook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub complete: ::std::option::Option<
        unsafe extern "C" fn(sql: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub complete16: ::std::option::Option<
        unsafe extern "C" fn(sql: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub create_collation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
            arg5: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_void,
                    arg4: ::std::os::raw::c_int,
                    arg5: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_collation16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
            arg5: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_void,
                    arg4: ::std::os::raw::c_int,
                    arg5: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_function: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            xFunc: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xStep: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_function16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            xFunc: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xStep: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_module: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const sqlite3_module,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub data_count: ::std::option::Option<
        unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub db_handle:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> *mut sqlite3>,
    pub declare_vtab: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub enable_shared_cache: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub errcode:
        ::std::option::Option<unsafe extern "C" fn(db: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub errmsg: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3) -> *const ::std::os::raw::c_char,
    >,
    pub errmsg16: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3) -> *const ::std::os::raw::c_void,
    >,
    pub exec: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: sqlite3_callback,
            arg4: *mut ::std::os::raw::c_void,
            arg5: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub expired: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub finalize: ::std::option::Option<
        unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub free_table:
        ::std::option::Option<unsafe extern "C" fn(result: *mut *mut ::std::os::raw::c_char)>,
    pub get_autocommit:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub get_auxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub get_table: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut *mut *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_int,
            arg6: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub global_recover: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub interruptx: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3)>,
    pub last_insert_rowid:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite_int64>,
    pub libversion: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub libversion_number: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,
    >,
    pub mprintf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            ...
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut sqlite3,
        ) -> ::std::os::raw::c_int,
    >,
    pub open16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *mut *mut sqlite3,
        ) -> ::std::os::raw::c_int,
    >,
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut *mut sqlite3_stmt,
            arg5: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub prepare16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: *mut *mut sqlite3_stmt,
            arg5: *mut *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub profile: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: sqlite_uint64,
                ),
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub progress_handler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
            >,
            arg4: *mut ::std::os::raw::c_void,
        ),
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub reset: ::std::option::Option<
        unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub result_blob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_double:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: f64)>,
    pub result_error: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ),
    >,
    pub result_error16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
        ),
    >,
    pub result_int: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int),
    >,
    pub result_int64:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: sqlite_int64)>,
    pub result_null: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    pub result_text: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_text16: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_text16be: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_text16le: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_value: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value),
    >,
    pub rollback_hook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
            arg3: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub set_authorizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *const ::std::os::raw::c_char,
                    arg5: *const ::std::os::raw::c_char,
                    arg6: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_int,
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_auxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub xsnprintf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            ...
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub step: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub table_column_metadata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *mut *const ::std::os::raw::c_char,
            arg6: *mut *const ::std::os::raw::c_char,
            arg7: *mut ::std::os::raw::c_int,
            arg8: *mut ::std::os::raw::c_int,
            arg9: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub thread_cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub total_changes:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub trace: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            xTrace: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_char,
                ),
            >,
            arg2: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub transfer_bindings: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: *mut sqlite3_stmt,
        ) -> ::std::os::raw::c_int,
    >,
    pub update_hook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *const ::std::os::raw::c_char,
                    arg5: sqlite_int64,
                ),
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub user_data: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context) -> *mut ::std::os::raw::c_void,
    >,
    pub value_blob: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void,
    >,
    pub value_bytes: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub value_bytes16: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub value_double: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_value) -> f64>,
    pub value_int: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub value_int64:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_value) -> sqlite_int64>,
    pub value_numeric_type: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub value_text: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_uchar,
    >,
    pub value_text16: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void,
    >,
    pub value_text16be: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void,
    >,
    pub value_text16le: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void,
    >,
    pub value_type: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub vmprintf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub overload_function: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            zFuncName: *const ::std::os::raw::c_char,
            nArg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub prepare_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut *mut sqlite3_stmt,
            arg5: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub prepare16_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: *mut *mut sqlite3_stmt,
            arg5: *mut *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub clear_bindings: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub create_module_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const sqlite3_module,
            arg4: *mut ::std::os::raw::c_void,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_zeroblob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub blob_bytes: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int,
    >,
    pub blob_close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int,
    >,
    pub blob_open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: sqlite3_int64,
            arg6: ::std::os::raw::c_int,
            arg7: *mut *mut sqlite3_blob,
        ) -> ::std::os::raw::c_int,
    >,
    pub blob_read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_blob,
            arg2: *mut ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub blob_write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_blob,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_collation_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
            arg5: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_void,
                    arg4: ::std::os::raw::c_int,
                    arg5: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg6: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub file_control: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub memory_highwater:
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> sqlite3_int64>,
    pub memory_used: ::std::option::Option<unsafe extern "C" fn() -> sqlite3_int64>,
    pub mutex_alloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex,
    >,
    pub mutex_enter: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub mutex_leave: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub mutex_try: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
    pub open_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut sqlite3,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub release_memory: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub result_error_nomem: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    pub result_error_toobig:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    pub sleep: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub soft_heap_limit: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub vfs_find: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut sqlite3_vfs,
    >,
    pub vfs_register: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub vfs_unregister: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vfs) -> ::std::os::raw::c_int,
    >,
    pub xthreadsafe: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub result_zeroblob: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int),
    >,
    pub result_error_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int),
    >,
    pub test_control: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int,
    >,
    pub randomness: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_void),
    >,
    pub context_db_handle:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context) -> *mut sqlite3>,
    pub extended_result_codes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub limit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_stmt: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3, arg2: *mut sqlite3_stmt) -> *mut sqlite3_stmt,
    >,
    pub sql: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> *const ::std::os::raw::c_char,
    >,
    pub status: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub backup_finish: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int,
    >,
    pub backup_init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut sqlite3,
            arg4: *const ::std::os::raw::c_char,
        ) -> *mut sqlite3_backup,
    >,
    pub backup_pagecount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int,
    >,
    pub backup_remaining: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int,
    >,
    pub backup_step: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_backup,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub compileoption_get: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
    >,
    pub compileoption_used: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub create_function_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            xFunc: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xStep: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub db_config: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub db_mutex:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> *mut sqlite3_mutex>,
    pub db_status: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
            arg5: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub extended_errcode:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub log: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char, ...),
    >,
    pub soft_heap_limit64:
        ::std::option::Option<unsafe extern "C" fn(arg1: sqlite3_int64) -> sqlite3_int64>,
    pub sourceid: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub stmt_status: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub strnicmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub unlock_notify: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                ),
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub wal_autocheckpoint: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub wal_checkpoint: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub wal_hook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *mut sqlite3,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg3: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub blob_reopen: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_blob, arg2: sqlite3_int64) -> ::std::os::raw::c_int,
    >,
    pub vtab_config: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            op: ::std::os::raw::c_int,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub vtab_on_conflict:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub close_v2:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub db_filename: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub db_readonly: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub db_release_memory:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub errstr: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
    >,
    pub stmt_busy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub stmt_readonly: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub stricmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub uri_boolean: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub uri_int64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: sqlite3_int64,
        ) -> sqlite3_int64,
    >,
    pub uri_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub xvsnprintf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub wal_checkpoint_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub auto_extension: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_blob64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            arg4: sqlite3_uint64,
            arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_text64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: sqlite3_uint64,
            arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
            arg6: ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
    >,
    pub cancel_auto_extension: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_int,
    >,
    pub load_extension: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub malloc64: ::std::option::Option<
        unsafe extern "C" fn(arg1: sqlite3_uint64) -> *mut ::std::os::raw::c_void,
    >,
    pub msize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> sqlite3_uint64,
    >,
    pub realloc64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: sqlite3_uint64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub reset_auto_extension: ::std::option::Option<unsafe extern "C" fn()>,
    pub result_blob64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_void,
            arg3: sqlite3_uint64,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub result_text64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *const ::std::os::raw::c_char,
            arg3: sqlite3_uint64,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
            arg5: ::std::os::raw::c_uchar,
        ),
    >,
    pub strglob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub value_dup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const sqlite3_value) -> *mut sqlite3_value,
    >,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_value)>,
    pub result_zeroblob64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: sqlite3_uint64,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_zeroblob64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: sqlite3_uint64,
        ) -> ::std::os::raw::c_int,
    >,
    pub value_subtype: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_uint,
    >,
    pub result_subtype: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_uint),
    >,
    pub status64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut sqlite3_int64,
            arg3: *mut sqlite3_int64,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub strlike: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub db_cacheflush:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub system_errno:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub trace_v2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_uint,
            arg3: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: ::std::os::raw::c_uint,
                    arg2: *mut ::std::os::raw::c_void,
                    arg3: *mut ::std::os::raw::c_void,
                    arg4: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub expanded_sql: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> *mut ::std::os::raw::c_char,
    >,
    pub set_last_insert_rowid:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3, arg2: sqlite3_int64)>,
    pub prepare_v3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_uint,
            arg5: *mut *mut sqlite3_stmt,
            arg6: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub prepare16_v3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_void,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_uint,
            arg5: *mut *mut sqlite3_stmt,
            arg6: *mut *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub bind_pointer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const ::std::os::raw::c_char,
            arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub result_pointer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ),
    >,
    pub value_pointer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_value,
            arg2: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub vtab_nochange: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int,
    >,
    pub value_nochange: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub vtab_collation: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_index_info,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub keyword_count: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub keyword_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub keyword_check: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub str_new:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> *mut sqlite3_str>,
    pub str_finish: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char,
    >,
    pub str_appendf: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str, zFormat: *const ::std::os::raw::c_char, ...),
    >,
    pub str_vappendf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_str,
            zFormat: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    pub str_append: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_str,
            zIn: *const ::std::os::raw::c_char,
            N: ::std::os::raw::c_int,
        ),
    >,
    pub str_appendall: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str, zIn: *const ::std::os::raw::c_char),
    >,
    pub str_appendchar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_str,
            N: ::std::os::raw::c_int,
            C: ::std::os::raw::c_char,
        ),
    >,
    pub str_reset: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_str)>,
    pub str_errcode: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int,
    >,
    pub str_length: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int,
    >,
    pub str_value: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char,
    >,
    pub create_window_function: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            xStep: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
            xValue: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
            xInv: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub normalized_sql: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> *const ::std::os::raw::c_char,
    >,
    pub stmt_isexplain: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int,
    >,
    pub value_frombind: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub drop_modules: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *mut *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub hard_heap_limit64:
        ::std::option::Option<unsafe extern "C" fn(arg1: sqlite3_int64) -> sqlite3_int64>,
    pub uri_key: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub filename_database: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char,
    >,
    pub filename_journal: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char,
    >,
    pub filename_wal: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char,
    >,
    pub create_filename: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
            arg5: *mut *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub free_filename:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    pub database_file_object: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut sqlite3_file,
    >,
    pub txn_state: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub changes64: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite3_int64>,
    pub total_changes64:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite3_int64>,
    pub autovacuum_pages: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_uint,
                    arg4: ::std::os::raw::c_uint,
                    arg5: ::std::os::raw::c_uint,
                ) -> ::std::os::raw::c_uint,
            >,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub error_offset:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub vtab_rhs_value: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_index_info,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub vtab_distinct: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_index_info) -> ::std::os::raw::c_int,
    >,
    pub vtab_in: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_index_info,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub vtab_in_first: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_value,
            arg2: *mut *mut sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub vtab_in_next: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_value,
            arg2: *mut *mut sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_uchar,
            arg4: sqlite3_int64,
            arg5: sqlite3_int64,
            arg6: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut sqlite3_int64,
            arg4: ::std::os::raw::c_uint,
        ) -> *mut ::std::os::raw::c_uchar,
    >,
    pub db_name: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub value_encoding: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int,
    >,
    pub is_interrupted:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int>,
    pub stmt_explain: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_stmt,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_clientdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub set_clientdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
}
pub type sqlite3_loadext_entry = ::std::option::Option<
    unsafe extern "C" fn(
        db: *mut sqlite3,
        pzErrMsg: *mut *mut ::std::os::raw::c_char,
        pThunk: *const sqlite3_api_routines,
    ) -> ::std::os::raw::c_int,
>;
static __SQLITE3_AGGREGATE_CONTEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_aggregate_context(
    arg1: *mut sqlite3_context,
    nBytes: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_AGGREGATE_CONTEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        nBytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, nBytes)
}

static __SQLITE3_BIND_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_blob(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_void,
    n: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, n, arg4)
}

static __SQLITE3_BIND_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_double(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: f64,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: f64,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BIND_INT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_int(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_INT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BIND_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_int64(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: sqlite_int64,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: sqlite_int64,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BIND_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_null(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_BIND_PARAMETER_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_parameter_count(
    arg1: *mut sqlite3_stmt,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_PARAMETER_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BIND_PARAMETER_INDEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_parameter_index(
    arg1: *mut sqlite3_stmt,
    zName: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_PARAMETER_INDEX
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        zName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, zName)
}

static __SQLITE3_BIND_PARAMETER_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_parameter_name(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_BIND_PARAMETER_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_BIND_TEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_text(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_char,
    n: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_TEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, n, arg4)
}

static __SQLITE3_BIND_TEXT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_text16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_void,
    arg4: ::std::os::raw::c_int,
    arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_TEXT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_BIND_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_value(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const sqlite3_value,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const sqlite3_value,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BUSY_HANDLER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_busy_handler(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BUSY_HANDLER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BUSY_TIMEOUT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_busy_timeout(
    arg1: *mut sqlite3,
    ms: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BUSY_TIMEOUT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, ms)
}

static __SQLITE3_CHANGES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CHANGES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_close(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CLOSE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_COLLATION_NEEDED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_collation_needed(
    arg1: *mut sqlite3,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut sqlite3,
            eTextRep: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
        ),
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLLATION_NEEDED.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                eTextRep: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
            ),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_COLLATION_NEEDED16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_collation_needed16(
    arg1: *mut sqlite3,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut sqlite3,
            eTextRep: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
        ),
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLLATION_NEEDED16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                eTextRep: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
            ),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_COLUMN_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_blob(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_BYTES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_bytes(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLUMN_BYTES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_BYTES16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_bytes16(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLUMN_BYTES16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLUMN_COUNT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(pStmt)
}

static __SQLITE3_COLUMN_DATABASE_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_database_name(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COLUMN_DATABASE_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_DATABASE_NAME16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_database_name16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_DATABASE_NAME16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_DECLTYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_decltype(
    arg1: *mut sqlite3_stmt,
    i: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COLUMN_DECLTYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, i)
}

static __SQLITE3_COLUMN_DECLTYPE16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_decltype16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_DECLTYPE16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_double(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> f64 {
    let ptr = __SQLITE3_COLUMN_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> f64 = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_INT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_int(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLUMN_INT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_int64(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> sqlite_int64 {
    let ptr = __SQLITE3_COLUMN_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> sqlite_int64 = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_name(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COLUMN_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_NAME16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_name16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_NAME16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_ORIGIN_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_origin_name(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COLUMN_ORIGIN_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_ORIGIN_NAME16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_origin_name16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_ORIGIN_NAME16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_TABLE_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_table_name(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COLUMN_TABLE_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_TABLE_NAME16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_table_name16(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_TABLE_NAME16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COLUMN_TEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_text(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_uchar {
    let ptr = __SQLITE3_COLUMN_TEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_TEXT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_text16(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_COLUMN_TEXT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_type(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COLUMN_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COLUMN_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_column_value(
    arg1: *mut sqlite3_stmt,
    iCol: ::std::os::raw::c_int,
) -> *mut sqlite3_value {
    let ptr = __SQLITE3_COLUMN_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *mut sqlite3_value = ::std::mem::transmute(ptr);
    (fun)(arg1, iCol)
}

static __SQLITE3_COMMIT_HOOK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_commit_hook(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_COMMIT_HOOK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_COMPLETE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_complete(
    sql: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COMPLETE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        sql: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(sql)
}

static __SQLITE3_COMPLETE16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_complete16(
    sql: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COMPLETE16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        sql: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(sql)
}

static __SQLITE3_CREATE_COLLATION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_collation(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_void,
    arg5: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_int,
            arg5: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_COLLATION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_CREATE_COLLATION16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_collation16(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_void,
    arg5: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_int,
            arg5: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_COLLATION16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_CREATE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_function(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_void,
    xFunc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xStep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_FUNCTION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, xFunc, xStep, xFinal)
}

static __SQLITE3_CREATE_FUNCTION16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_function16(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_void,
    xFunc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xStep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_FUNCTION16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, xFunc, xStep, xFinal)
}

static __SQLITE3_CREATE_MODULE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_module(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const sqlite3_module,
    arg4: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_MODULE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const sqlite3_module,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_DATA_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DATA_COUNT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(pStmt)
}

static __SQLITE3_DB_HANDLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -> *mut sqlite3 {
    let ptr = __SQLITE3_DB_HANDLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> *mut sqlite3 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_DECLARE_VTAB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_declare_vtab(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DECLARE_VTAB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_ENABLE_SHARED_CACHE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_enable_shared_cache(
    arg1: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_ENABLE_SHARED_CACHE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_ERRCODE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_errcode(db: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_ERRCODE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(db: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(db)
}

static __SQLITE3_ERRMSG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_errmsg(arg1: *mut sqlite3) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_ERRMSG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> *const ::std::os::raw::c_char = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_ERRMSG16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_errmsg16(arg1: *mut sqlite3) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_ERRMSG16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> *const ::std::os::raw::c_void = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_EXEC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_exec(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: sqlite3_callback,
    arg4: *mut ::std::os::raw::c_void,
    arg5: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_EXEC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: sqlite3_callback,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_FINALIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_FINALIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(pStmt)
}

static __SQLITE3_FREE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_free(arg1: *mut ::std::os::raw::c_void) {
    let ptr = __SQLITE3_FREE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_FREE_TABLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_free_table(result: *mut *mut ::std::os::raw::c_char) {
    let ptr = __SQLITE3_FREE_TABLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(result: *mut *mut ::std::os::raw::c_char) = ::std::mem::transmute(
        ptr,
    );
    (fun)(result)
}

static __SQLITE3_GET_AUTOCOMMIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_get_autocommit(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_GET_AUTOCOMMIT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_GET_AUXDATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_get_auxdata(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_GET_AUXDATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_GET_TABLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_get_table(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut *mut *mut ::std::os::raw::c_char,
    arg4: *mut ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_int,
    arg6: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_GET_TABLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_INTERRUPT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_interrupt(arg1: *mut sqlite3) {
    let ptr = __SQLITE3_INTERRUPT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_LAST_INSERT_ROWID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -> sqlite_int64 {
    let ptr = __SQLITE3_LAST_INSERT_ROWID.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_LIBVERSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_libversion() -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_LIBVERSION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> *const ::std::os::raw::c_char = ::std::mem::transmute(
        ptr,
    );
    (fun)()
}

static __SQLITE3_LIBVERSION_NUMBER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_libversion_number() -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_LIBVERSION_NUMBER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)()
}

static __SQLITE3_MALLOC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_malloc(
    arg1: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_MALLOC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_OPEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_open(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut sqlite3,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_OPEN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut sqlite3,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_OPEN16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_open16(
    arg1: *const ::std::os::raw::c_void,
    arg2: *mut *mut sqlite3,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_OPEN16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut *mut sqlite3,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_PREPARE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut *mut sqlite3_stmt,
    arg5: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut sqlite3_stmt,
        arg5: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_PREPARE16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare16(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: *mut *mut sqlite3_stmt,
    arg5: *mut *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut sqlite3_stmt,
        arg5: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_PROFILE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_profile(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: sqlite_uint64,
        ),
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_PROFILE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: sqlite_uint64,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_PROGRESS_HANDLER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_progress_handler(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    arg4: *mut ::std::os::raw::c_void,
) {
    let ptr = __SQLITE3_PROGRESS_HANDLER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_REALLOC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_realloc(
    arg1: *mut ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_REALLOC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_RESET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_RESET.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(pStmt)
}

static __SQLITE3_RESULT_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_blob(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64) {
    let ptr = __SQLITE3_RESULT_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: f64) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1, arg2)
}

static __SQLITE3_RESULT_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_error(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_RESULT_ERROR.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_RESULT_ERROR16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_error16(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_RESULT_ERROR16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_RESULT_INT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_int(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_RESULT_INT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_RESULT_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite_int64) {
    let ptr = __SQLITE3_RESULT_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context, arg2: sqlite_int64) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1, arg2)
}

static __SQLITE3_RESULT_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_null(arg1: *mut sqlite3_context) {
    let ptr = __SQLITE3_RESULT_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_RESULT_TEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_text(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_TEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_TEXT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_text16(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_TEXT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_TEXT16BE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_text16be(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_TEXT16BE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_TEXT16LE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_text16le(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_TEXT16LE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_value(
    arg1: *mut sqlite3_context,
    arg2: *mut sqlite3_value,
) {
    let ptr = __SQLITE3_RESULT_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *mut sqlite3_value,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_ROLLBACK_HOOK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_rollback_hook(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    arg3: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_ROLLBACK_HOOK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_SET_AUTHORIZER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_set_authorizer(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *const ::std::os::raw::c_char,
            arg6: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_SET_AUTHORIZER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char,
                arg5: *const ::std::os::raw::c_char,
                arg6: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_SET_AUXDATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_set_auxdata(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_void,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_SET_AUXDATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_STEP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_step(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STEP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_TABLE_COLUMN_METADATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_table_column_metadata(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const ::std::os::raw::c_char,
    arg4: *const ::std::os::raw::c_char,
    arg5: *mut *const ::std::os::raw::c_char,
    arg6: *mut *const ::std::os::raw::c_char,
    arg7: *mut ::std::os::raw::c_int,
    arg8: *mut ::std::os::raw::c_int,
    arg9: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_TABLE_COLUMN_METADATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut *const ::std::os::raw::c_char,
        arg6: *mut *const ::std::os::raw::c_char,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut ::std::os::raw::c_int,
        arg9: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

static __SQLITE3_TOTAL_CHANGES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_total_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_TOTAL_CHANGES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_TRACE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_trace(
    arg1: *mut sqlite3,
    xTrace: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
        ),
    >,
    arg2: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_TRACE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        xTrace: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
            ),
        >,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, xTrace, arg2)
}

static __SQLITE3_UPDATE_HOOK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_update_hook(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: sqlite_int64,
        ),
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_UPDATE_HOOK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char,
                arg5: sqlite_int64,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_USER_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_user_data(
    arg1: *mut sqlite3_context,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_USER_DATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_blob(
    arg1: *mut sqlite3_value,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_VALUE_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_BYTES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_BYTES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_BYTES16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_bytes16(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_BYTES16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_double(arg1: *mut sqlite3_value) -> f64 {
    let ptr = __SQLITE3_VALUE_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> f64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_INT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_int(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_INT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_int64(arg1: *mut sqlite3_value) -> sqlite_int64 {
    let ptr = __SQLITE3_VALUE_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> sqlite_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_NUMERIC_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_numeric_type(
    arg1: *mut sqlite3_value,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_NUMERIC_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_TEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_text(
    arg1: *mut sqlite3_value,
) -> *const ::std::os::raw::c_uchar {
    let ptr = __SQLITE3_VALUE_TEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
    ) -> *const ::std::os::raw::c_uchar = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_TEXT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_text16(
    arg1: *mut sqlite3_value,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_VALUE_TEXT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_TEXT16BE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_text16be(
    arg1: *mut sqlite3_value,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_VALUE_TEXT16BE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_TEXT16LE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_text16le(
    arg1: *mut sqlite3_value,
) -> *const ::std::os::raw::c_void {
    let ptr = __SQLITE3_VALUE_TEXT16LE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
    ) -> *const ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VALUE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_type(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_OVERLOAD_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_overload_function(
    arg1: *mut sqlite3,
    zFuncName: *const ::std::os::raw::c_char,
    nArg: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_OVERLOAD_FUNCTION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        zFuncName: *const ::std::os::raw::c_char,
        nArg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, zFuncName, nArg)
}

static __SQLITE3_PREPARE_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut *mut sqlite3_stmt,
    arg5: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut sqlite3_stmt,
        arg5: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_PREPARE16_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare16_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: *mut *mut sqlite3_stmt,
    arg5: *mut *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE16_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut sqlite3_stmt,
        arg5: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_CLEAR_BINDINGS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CLEAR_BINDINGS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_CREATE_MODULE_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_module_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const sqlite3_module,
    arg4: *mut ::std::os::raw::c_void,
    xDestroy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_MODULE_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const sqlite3_module,
        arg4: *mut ::std::os::raw::c_void,
        xDestroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, xDestroy)
}

static __SQLITE3_BIND_ZEROBLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_zeroblob(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_ZEROBLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BLOB_BYTES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_BYTES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BLOB_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_CLOSE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BLOB_OPEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_open(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const ::std::os::raw::c_char,
    arg4: *const ::std::os::raw::c_char,
    arg5: sqlite3_int64,
    arg6: ::std::os::raw::c_int,
    arg7: *mut *mut sqlite3_blob,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_OPEN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: sqlite3_int64,
        arg6: ::std::os::raw::c_int,
        arg7: *mut *mut sqlite3_blob,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

static __SQLITE3_BLOB_READ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_read(
    arg1: *mut sqlite3_blob,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_READ.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_blob,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_BLOB_WRITE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_write(
    arg1: *mut sqlite3_blob,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_WRITE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_blob,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_CREATE_COLLATION_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_collation_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_void,
    arg5: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_int,
            arg5: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    arg6: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_COLLATION_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg6: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_FILE_CONTROL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_file_control(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_FILE_CONTROL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_MEMORY_HIGHWATER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_memory_highwater(arg1: ::std::os::raw::c_int) -> sqlite3_int64 {
    let ptr = __SQLITE3_MEMORY_HIGHWATER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> sqlite3_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_MEMORY_USED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_memory_used() -> sqlite3_int64 {
    let ptr = __SQLITE3_MEMORY_USED.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> sqlite3_int64 = ::std::mem::transmute(ptr);
    (fun)()
}

static __SQLITE3_MUTEX_ALLOC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_mutex_alloc(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex {
    let ptr = __SQLITE3_MUTEX_ALLOC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_MUTEX_ENTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex) {
    let ptr = __SQLITE3_MUTEX_ENTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_mutex) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_MUTEX_FREE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex) {
    let ptr = __SQLITE3_MUTEX_FREE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_mutex) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_MUTEX_LEAVE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex) {
    let ptr = __SQLITE3_MUTEX_LEAVE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_mutex) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_MUTEX_TRY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_MUTEX_TRY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_OPEN_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_open_v2(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut sqlite3,
    arg3: ::std::os::raw::c_int,
    arg4: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_OPEN_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut sqlite3,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RELEASE_MEMORY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_release_memory(
    arg1: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_RELEASE_MEMORY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_RESULT_ERROR_NOMEM: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context) {
    let ptr = __SQLITE3_RESULT_ERROR_NOMEM.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_RESULT_ERROR_TOOBIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context) {
    let ptr = __SQLITE3_RESULT_ERROR_TOOBIG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_SLEEP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_sleep(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_SLEEP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_SOFT_HEAP_LIMIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_soft_heap_limit(arg1: ::std::os::raw::c_int) {
    let ptr = __SQLITE3_SOFT_HEAP_LIMIT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: ::std::os::raw::c_int) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VFS_FIND: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vfs_find(arg1: *const ::std::os::raw::c_char) -> *mut sqlite3_vfs {
    let ptr = __SQLITE3_VFS_FIND.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut sqlite3_vfs = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VFS_REGISTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vfs_register(
    arg1: *mut sqlite3_vfs,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VFS_REGISTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_vfs,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VFS_UNREGISTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VFS_UNREGISTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_vfs) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_THREADSAFE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_threadsafe() -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_THREADSAFE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)()
}

static __SQLITE3_RESULT_ZEROBLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_zeroblob(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_RESULT_ZEROBLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_RESULT_ERROR_CODE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_error_code(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_RESULT_ERROR_CODE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_RANDOMNESS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_randomness(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_void,
) {
    let ptr = __SQLITE3_RANDOMNESS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_CONTEXT_DB_HANDLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -> *mut sqlite3 {
    let ptr = __SQLITE3_CONTEXT_DB_HANDLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context) -> *mut sqlite3 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_EXTENDED_RESULT_CODES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_extended_result_codes(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_EXTENDED_RESULT_CODES
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_LIMIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_limit(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_LIMIT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_NEXT_STMT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_next_stmt(
    arg1: *mut sqlite3,
    arg2: *mut sqlite3_stmt,
) -> *mut sqlite3_stmt {
    let ptr = __SQLITE3_NEXT_STMT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *mut sqlite3_stmt,
    ) -> *mut sqlite3_stmt = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_SQL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_sql(arg1: *mut sqlite3_stmt) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_SQL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_STATUS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_status(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STATUS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_BACKUP_FINISH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_backup_finish(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BACKUP_FINISH.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BACKUP_INIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_backup_init(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut sqlite3,
    arg4: *const ::std::os::raw::c_char,
) -> *mut sqlite3_backup {
    let ptr = __SQLITE3_BACKUP_INIT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut sqlite3,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut sqlite3_backup = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_BACKUP_PAGECOUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_backup_pagecount(
    arg1: *mut sqlite3_backup,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BACKUP_PAGECOUNT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BACKUP_REMAINING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_backup_remaining(
    arg1: *mut sqlite3_backup,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BACKUP_REMAINING.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_backup) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_BACKUP_STEP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_backup_step(
    arg1: *mut sqlite3_backup,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BACKUP_STEP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_backup,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_COMPILEOPTION_GET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_compileoption_get(
    arg1: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_COMPILEOPTION_GET.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_COMPILEOPTION_USED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_compileoption_used(
    arg1: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_COMPILEOPTION_USED.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_CREATE_FUNCTION_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_function_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_void,
    xFunc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xStep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    xDestroy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_FUNCTION_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xDestroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, xFunc, xStep, xFinal, xDestroy)
}

static __SQLITE3_DB_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_config(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DB_CONFIG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_DB_MUTEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_mutex(arg1: *mut sqlite3) -> *mut sqlite3_mutex {
    let ptr = __SQLITE3_DB_MUTEX.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> *mut sqlite3_mutex = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_DB_STATUS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_status(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_int,
    arg5: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DB_STATUS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_EXTENDED_ERRCODE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_extended_errcode(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_EXTENDED_ERRCODE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_LOG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_log(
    arg1: ::std::os::raw::c_int,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const ::std::os::raw::c_char,
) {
    let ptr = __SQLITE3_LOG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_SOFT_HEAP_LIMIT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_soft_heap_limit64(arg1: sqlite3_int64) -> sqlite3_int64 {
    let ptr = __SQLITE3_SOFT_HEAP_LIMIT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: sqlite3_int64) -> sqlite3_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_SOURCEID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_sourceid() -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_SOURCEID.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> *const ::std::os::raw::c_char = ::std::mem::transmute(
        ptr,
    );
    (fun)()
}

static __SQLITE3_STMT_STATUS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stmt_status(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STMT_STATUS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_STRNICMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_strnicmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STRNICMP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_UNLOCK_NOTIFY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_unlock_notify(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
        ),
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_UNLOCK_NOTIFY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_WAL_AUTOCHECKPOINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_wal_autocheckpoint(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_WAL_AUTOCHECKPOINT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_WAL_CHECKPOINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_wal_checkpoint(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_WAL_CHECKPOINT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_WAL_HOOK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_wal_hook(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut sqlite3,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    arg3: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_WAL_HOOK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_BLOB_REOPEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_blob_reopen(
    arg1: *mut sqlite3_blob,
    arg2: sqlite3_int64,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BLOB_REOPEN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_blob,
        arg2: sqlite3_int64,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VTAB_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_config(
    arg1: *mut sqlite3,
    op: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_CONFIG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        op: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, op)
}

static __SQLITE3_VTAB_ON_CONFLICT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_ON_CONFLICT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_CLOSE_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_close_v2(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CLOSE_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_DB_FILENAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_filename(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_DB_FILENAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_DB_READONLY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_readonly(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DB_READONLY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_DB_RELEASE_MEMORY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_release_memory(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DB_RELEASE_MEMORY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_ERRSTR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_errstr(
    arg1: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_ERRSTR.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_STMT_BUSY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STMT_BUSY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STMT_READONLY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stmt_readonly(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STMT_READONLY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STRICMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stricmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STRICMP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_URI_BOOLEAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_uri_boolean(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_URI_BOOLEAN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_URI_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_uri_int64(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: sqlite3_int64,
) -> sqlite3_int64 {
    let ptr = __SQLITE3_URI_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: sqlite3_int64,
    ) -> sqlite3_int64 = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_URI_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_uri_parameter(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_URI_PARAMETER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_WAL_CHECKPOINT_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_wal_checkpoint_v2(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *mut ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_WAL_CHECKPOINT_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_AUTO_EXTENSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_auto_extension(
    arg1: ::std::option::Option<unsafe extern "C" fn()>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_AUTO_EXTENSION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_BIND_BLOB64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_blob64(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_void,
    arg4: sqlite3_uint64,
    arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_BLOB64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        arg4: sqlite3_uint64,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_BIND_TEXT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_text64(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *const ::std::os::raw::c_char,
    arg4: sqlite3_uint64,
    arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    arg6: ::std::os::raw::c_uchar,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_TEXT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: sqlite3_uint64,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        arg6: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_CANCEL_AUTO_EXTENSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_cancel_auto_extension(
    arg1: ::std::option::Option<unsafe extern "C" fn()>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CANCEL_AUTO_EXTENSION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_LOAD_EXTENSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_load_extension(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const ::std::os::raw::c_char,
    arg4: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_LOAD_EXTENSION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_MALLOC64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_malloc64(arg1: sqlite3_uint64) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_MALLOC64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: sqlite3_uint64) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_MSIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_msize(arg1: *mut ::std::os::raw::c_void) -> sqlite3_uint64 {
    let ptr = __SQLITE3_MSIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> sqlite3_uint64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_REALLOC64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_realloc64(
    arg1: *mut ::std::os::raw::c_void,
    arg2: sqlite3_uint64,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_REALLOC64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: sqlite3_uint64,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_RESET_AUTO_EXTENSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_reset_auto_extension() {
    let ptr = __SQLITE3_RESET_AUTO_EXTENSION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() = ::std::mem::transmute(ptr);
    (fun)()
}

static __SQLITE3_RESULT_BLOB64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_blob64(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_void,
    arg3: sqlite3_uint64,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_BLOB64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: sqlite3_uint64,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_RESULT_TEXT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_text64(
    arg1: *mut sqlite3_context,
    arg2: *const ::std::os::raw::c_char,
    arg3: sqlite3_uint64,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    arg5: ::std::os::raw::c_uchar,
) {
    let ptr = __SQLITE3_RESULT_TEXT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: sqlite3_uint64,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        arg5: ::std::os::raw::c_uchar,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_STRGLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_strglob(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STRGLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VALUE_DUP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_dup(arg1: *const sqlite3_value) -> *mut sqlite3_value {
    let ptr = __SQLITE3_VALUE_DUP.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *const sqlite3_value) -> *mut sqlite3_value = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_FREE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_free(arg1: *mut sqlite3_value) {
    let ptr = __SQLITE3_VALUE_FREE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_RESULT_ZEROBLOB64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_zeroblob64(
    arg1: *mut sqlite3_context,
    arg2: sqlite3_uint64,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_RESULT_ZEROBLOB64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: sqlite3_uint64,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_BIND_ZEROBLOB64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_zeroblob64(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: sqlite3_uint64,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_ZEROBLOB64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: sqlite3_uint64,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_VALUE_SUBTYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -> ::std::os::raw::c_uint {
    let ptr = __SQLITE3_VALUE_SUBTYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_uint = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_RESULT_SUBTYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_subtype(
    arg1: *mut sqlite3_context,
    arg2: ::std::os::raw::c_uint,
) {
    let ptr = __SQLITE3_RESULT_SUBTYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: ::std::os::raw::c_uint,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_STATUS64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_status64(
    arg1: ::std::os::raw::c_int,
    arg2: *mut sqlite3_int64,
    arg3: *mut sqlite3_int64,
    arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STATUS64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sqlite3_int64,
        arg3: *mut sqlite3_int64,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_STRLIKE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_strlike(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STRLIKE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_DB_CACHEFLUSH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DB_CACHEFLUSH.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_SYSTEM_ERRNO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_system_errno(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_SYSTEM_ERRNO.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_TRACE_V2: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_trace_v2(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_uint,
    arg3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_uint,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    arg4: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_TRACE_V2.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_uint,
                arg2: *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_EXPANDED_SQL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_expanded_sql(
    arg1: *mut sqlite3_stmt,
) -> *mut ::std::os::raw::c_char {
    let ptr = __SQLITE3_EXPANDED_SQL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_SET_LAST_INSERT_ROWID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64) {
    let ptr = __SQLITE3_SET_LAST_INSERT_ROWID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3, arg2: sqlite3_int64) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1, arg2)
}

static __SQLITE3_PREPARE_V3: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare_v3(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_uint,
    arg5: *mut *mut sqlite3_stmt,
    arg6: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE_V3.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut *mut sqlite3_stmt,
        arg6: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_PREPARE16_V3: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_prepare16_v3(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_uint,
    arg5: *mut *mut sqlite3_stmt,
    arg6: *mut *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_PREPARE16_V3.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut *mut sqlite3_stmt,
        arg6: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_BIND_POINTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_bind_pointer(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
    arg3: *mut ::std::os::raw::c_void,
    arg4: *const ::std::os::raw::c_char,
    arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_BIND_POINTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_RESULT_POINTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_result_pointer(
    arg1: *mut sqlite3_context,
    arg2: *mut ::std::os::raw::c_void,
    arg3: *const ::std::os::raw::c_char,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) {
    let ptr = __SQLITE3_RESULT_POINTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_context,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_VALUE_POINTER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_pointer(
    arg1: *mut sqlite3_value,
    arg2: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_VALUE_POINTER.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VTAB_NOCHANGE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_nochange(
    arg1: *mut sqlite3_context,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_NOCHANGE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_NOCHANGE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_NOCHANGE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VTAB_COLLATION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_collation(
    arg1: *mut sqlite3_index_info,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_VTAB_COLLATION.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_index_info,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_KEYWORD_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_keyword_count() -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_KEYWORD_COUNT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn() -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)()
}

static __SQLITE3_KEYWORD_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_keyword_name(
    arg1: ::std::os::raw::c_int,
    arg2: *mut *const ::std::os::raw::c_char,
    arg3: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_KEYWORD_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_KEYWORD_CHECK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_keyword_check(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_KEYWORD_CHECK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_STR_NEW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_new(arg1: *mut sqlite3) -> *mut sqlite3_str {
    let ptr = __SQLITE3_STR_NEW.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> *mut sqlite3_str = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STR_FINISH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_finish(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char {
    let ptr = __SQLITE3_STR_FINISH.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_str,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_STR_APPEND: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_append(
    arg1: *mut sqlite3_str,
    zIn: *const ::std::os::raw::c_char,
    N: ::std::os::raw::c_int,
) {
    let ptr = __SQLITE3_STR_APPEND.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_str,
        zIn: *const ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, zIn, N)
}

static __SQLITE3_STR_APPENDALL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_appendall(
    arg1: *mut sqlite3_str,
    zIn: *const ::std::os::raw::c_char,
) {
    let ptr = __SQLITE3_STR_APPENDALL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_str,
        zIn: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, zIn)
}

static __SQLITE3_STR_APPENDCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_appendchar(
    arg1: *mut sqlite3_str,
    N: ::std::os::raw::c_int,
    C: ::std::os::raw::c_char,
) {
    let ptr = __SQLITE3_STR_APPENDCHAR.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_str,
        N: ::std::os::raw::c_int,
        C: ::std::os::raw::c_char,
    ) = ::std::mem::transmute(ptr);
    (fun)(arg1, N, C)
}

static __SQLITE3_STR_RESET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_reset(arg1: *mut sqlite3_str) {
    let ptr = __SQLITE3_STR_RESET.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_str) = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_STR_ERRCODE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STR_ERRCODE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_length(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STR_LENGTH.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STR_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_str_value(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char {
    let ptr = __SQLITE3_STR_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_str,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_CREATE_WINDOW_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_window_function(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
    arg5: *mut ::std::os::raw::c_void,
    xStep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    xValue: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    xInv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_context,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
        ),
    >,
    xDestroy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_CREATE_WINDOW_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xValue: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xInv: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xDestroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, xStep, xFinal, xValue, xInv, xDestroy)
}

static __SQLITE3_NORMALIZED_SQL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_normalized_sql(
    arg1: *mut sqlite3_stmt,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_NORMALIZED_SQL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_STMT_ISEXPLAIN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stmt_isexplain(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STMT_ISEXPLAIN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VALUE_FROMBIND: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_FROMBIND.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_DROP_MODULES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_drop_modules(
    arg1: *mut sqlite3,
    arg2: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DROP_MODULES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_HARD_HEAP_LIMIT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_hard_heap_limit64(arg1: sqlite3_int64) -> sqlite3_int64 {
    let ptr = __SQLITE3_HARD_HEAP_LIMIT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: sqlite3_int64) -> sqlite3_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_URI_KEY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_uri_key(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_URI_KEY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_FILENAME_DATABASE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_filename_database(
    arg1: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_FILENAME_DATABASE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_FILENAME_JOURNAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_filename_journal(
    arg1: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_FILENAME_JOURNAL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_FILENAME_WAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_filename_wal(
    arg1: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_FILENAME_WAL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_CREATE_FILENAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_create_filename(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *const ::std::os::raw::c_char,
    arg4: ::std::os::raw::c_int,
    arg5: *mut *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_CREATE_FILENAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5)
}

static __SQLITE3_FREE_FILENAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_free_filename(arg1: *const ::std::os::raw::c_char) {
    let ptr = __SQLITE3_FREE_FILENAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_DATABASE_FILE_OBJECT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_database_file_object(
    arg1: *const ::std::os::raw::c_char,
) -> *mut sqlite3_file {
    let ptr = __SQLITE3_DATABASE_FILE_OBJECT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut sqlite3_file = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_TXN_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_txn_state(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_TXN_STATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_CHANGES64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_changes64(arg1: *mut sqlite3) -> sqlite3_int64 {
    let ptr = __SQLITE3_CHANGES64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite3_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_TOTAL_CHANGES64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_total_changes64(arg1: *mut sqlite3) -> sqlite3_int64 {
    let ptr = __SQLITE3_TOTAL_CHANGES64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> sqlite3_int64 = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_AUTOVACUUM_PAGES: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_autovacuum_pages(
    arg1: *mut sqlite3,
    arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
            arg4: ::std::os::raw::c_uint,
            arg5: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    arg3: *mut ::std::os::raw::c_void,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_AUTOVACUUM_PAGES.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_uint,
                arg4: ::std::os::raw::c_uint,
                arg5: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_ERROR_OFFSET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_error_offset(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_ERROR_OFFSET.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_VTAB_RHS_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_rhs_value(
    arg1: *mut sqlite3_index_info,
    arg2: ::std::os::raw::c_int,
    arg3: *mut *mut sqlite3_value,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_RHS_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_index_info,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_VTAB_DISTINCT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_distinct(
    arg1: *mut sqlite3_index_info,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_DISTINCT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_index_info,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1)
}

static __SQLITE3_VTAB_IN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_in(
    arg1: *mut sqlite3_index_info,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_IN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_index_info,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3)
}

static __SQLITE3_VTAB_IN_FIRST: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_in_first(
    arg1: *mut sqlite3_value,
    arg2: *mut *mut sqlite3_value,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_IN_FIRST.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
        arg2: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VTAB_IN_NEXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_vtab_in_next(
    arg1: *mut sqlite3_value,
    arg2: *mut *mut sqlite3_value,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VTAB_IN_NEXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_value,
        arg2: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_DESERIALIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_deserialize(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut ::std::os::raw::c_uchar,
    arg4: sqlite3_int64,
    arg5: sqlite3_int64,
    arg6: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_DESERIALIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_uchar,
        arg4: sqlite3_int64,
        arg5: sqlite3_int64,
        arg6: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4, arg5, arg6)
}

static __SQLITE3_SERIALIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_serialize(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut sqlite3_int64,
    arg4: ::std::os::raw::c_uint,
) -> *mut ::std::os::raw::c_uchar {
    let ptr = __SQLITE3_SERIALIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut sqlite3_int64,
        arg4: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

static __SQLITE3_DB_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_db_name(
    arg1: *mut sqlite3,
    arg2: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    let ptr = __SQLITE3_DB_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_VALUE_ENCODING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_value_encoding(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_VALUE_ENCODING.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_IS_INTERRUPTED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_is_interrupted(arg1: *mut sqlite3) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_IS_INTERRUPTED.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(arg1: *mut sqlite3) -> ::std::os::raw::c_int = ::std::mem::transmute(
        ptr,
    );
    (fun)(arg1)
}

static __SQLITE3_STMT_EXPLAIN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_stmt_explain(
    arg1: *mut sqlite3_stmt,
    arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_STMT_EXPLAIN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_GET_CLIENTDATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_get_clientdata(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_void {
    let ptr = __SQLITE3_GET_CLIENTDATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2)
}

static __SQLITE3_SET_CLIENTDATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn sqlite3_set_clientdata(
    arg1: *mut sqlite3,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut ::std::os::raw::c_void,
    arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
) -> ::std::os::raw::c_int {
    let ptr = __SQLITE3_SET_CLIENTDATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(! ptr.is_null(), "SQLite API not initialized or SQLite feature omitted");
    let fun: unsafe extern "C" fn(
        arg1: *mut sqlite3,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int = ::std::mem::transmute(ptr);
    (fun)(arg1, arg2, arg3, arg4)
}

/// Like SQLITE_EXTENSION_INIT2 macro
pub unsafe fn rusqlite_extension_init2(
    p_api: *mut sqlite3_api_routines,
) -> ::std::result::Result<(), crate::InitError> {
    if let Some(fun) = (*p_api).malloc {
        __SQLITE3_MALLOC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).libversion_number {
        let version = fun();
        if SQLITE_VERSION_NUMBER > version {
            return Err(crate::InitError::VersionMismatch {
                compile_time: SQLITE_VERSION_NUMBER,
                runtime: version,
            });
        }
    } else {
        return Err(crate::InitError::NullFunctionPointer);
    }
    if let Some(fun) = (*p_api).aggregate_context {
        __SQLITE3_AGGREGATE_CONTEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_blob {
        __SQLITE3_BIND_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_double {
        __SQLITE3_BIND_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_int {
        __SQLITE3_BIND_INT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_int64 {
        __SQLITE3_BIND_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_null {
        __SQLITE3_BIND_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_parameter_count {
        __SQLITE3_BIND_PARAMETER_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_parameter_index {
        __SQLITE3_BIND_PARAMETER_INDEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_parameter_name {
        __SQLITE3_BIND_PARAMETER_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_text {
        __SQLITE3_BIND_TEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_text16 {
        __SQLITE3_BIND_TEXT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_value {
        __SQLITE3_BIND_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).busy_handler {
        __SQLITE3_BUSY_HANDLER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).busy_timeout {
        __SQLITE3_BUSY_TIMEOUT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).changes {
        __SQLITE3_CHANGES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).close {
        __SQLITE3_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).collation_needed {
        __SQLITE3_COLLATION_NEEDED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).collation_needed16 {
        __SQLITE3_COLLATION_NEEDED16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_blob {
        __SQLITE3_COLUMN_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_bytes {
        __SQLITE3_COLUMN_BYTES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_bytes16 {
        __SQLITE3_COLUMN_BYTES16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_count {
        __SQLITE3_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_database_name {
        __SQLITE3_COLUMN_DATABASE_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_database_name16 {
        __SQLITE3_COLUMN_DATABASE_NAME16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_decltype {
        __SQLITE3_COLUMN_DECLTYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_decltype16 {
        __SQLITE3_COLUMN_DECLTYPE16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_double {
        __SQLITE3_COLUMN_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_int {
        __SQLITE3_COLUMN_INT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_int64 {
        __SQLITE3_COLUMN_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_name {
        __SQLITE3_COLUMN_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_name16 {
        __SQLITE3_COLUMN_NAME16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_origin_name {
        __SQLITE3_COLUMN_ORIGIN_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_origin_name16 {
        __SQLITE3_COLUMN_ORIGIN_NAME16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_table_name {
        __SQLITE3_COLUMN_TABLE_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_table_name16 {
        __SQLITE3_COLUMN_TABLE_NAME16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_text {
        __SQLITE3_COLUMN_TEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_text16 {
        __SQLITE3_COLUMN_TEXT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_type {
        __SQLITE3_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).column_value {
        __SQLITE3_COLUMN_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).commit_hook {
        __SQLITE3_COMMIT_HOOK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).complete {
        __SQLITE3_COMPLETE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).complete16 {
        __SQLITE3_COMPLETE16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_collation {
        __SQLITE3_CREATE_COLLATION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_collation16 {
        __SQLITE3_CREATE_COLLATION16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_function {
        __SQLITE3_CREATE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_function16 {
        __SQLITE3_CREATE_FUNCTION16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_module {
        __SQLITE3_CREATE_MODULE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).data_count {
        __SQLITE3_DATA_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_handle {
        __SQLITE3_DB_HANDLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).declare_vtab {
        __SQLITE3_DECLARE_VTAB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).enable_shared_cache {
        __SQLITE3_ENABLE_SHARED_CACHE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).errcode {
        __SQLITE3_ERRCODE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).errmsg {
        __SQLITE3_ERRMSG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).errmsg16 {
        __SQLITE3_ERRMSG16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).exec {
        __SQLITE3_EXEC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).finalize {
        __SQLITE3_FINALIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).free {
        __SQLITE3_FREE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).free_table {
        __SQLITE3_FREE_TABLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).get_autocommit {
        __SQLITE3_GET_AUTOCOMMIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).get_auxdata {
        __SQLITE3_GET_AUXDATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).get_table {
        __SQLITE3_GET_TABLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).interruptx {
        __SQLITE3_INTERRUPT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).last_insert_rowid {
        __SQLITE3_LAST_INSERT_ROWID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).libversion {
        __SQLITE3_LIBVERSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).libversion_number {
        __SQLITE3_LIBVERSION_NUMBER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).open {
        __SQLITE3_OPEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).open16 {
        __SQLITE3_OPEN16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare {
        __SQLITE3_PREPARE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare16 {
        __SQLITE3_PREPARE16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).profile {
        __SQLITE3_PROFILE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).progress_handler {
        __SQLITE3_PROGRESS_HANDLER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).realloc {
        __SQLITE3_REALLOC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).reset {
        __SQLITE3_RESET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_blob {
        __SQLITE3_RESULT_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_double {
        __SQLITE3_RESULT_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_error {
        __SQLITE3_RESULT_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_error16 {
        __SQLITE3_RESULT_ERROR16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_int {
        __SQLITE3_RESULT_INT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_int64 {
        __SQLITE3_RESULT_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_null {
        __SQLITE3_RESULT_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_text {
        __SQLITE3_RESULT_TEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_text16 {
        __SQLITE3_RESULT_TEXT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_text16be {
        __SQLITE3_RESULT_TEXT16BE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_text16le {
        __SQLITE3_RESULT_TEXT16LE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_value {
        __SQLITE3_RESULT_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).rollback_hook {
        __SQLITE3_ROLLBACK_HOOK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).set_authorizer {
        __SQLITE3_SET_AUTHORIZER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).set_auxdata {
        __SQLITE3_SET_AUXDATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).step {
        __SQLITE3_STEP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).table_column_metadata {
        __SQLITE3_TABLE_COLUMN_METADATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).total_changes {
        __SQLITE3_TOTAL_CHANGES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).trace {
        __SQLITE3_TRACE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).update_hook {
        __SQLITE3_UPDATE_HOOK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).user_data {
        __SQLITE3_USER_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_blob {
        __SQLITE3_VALUE_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_bytes {
        __SQLITE3_VALUE_BYTES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_bytes16 {
        __SQLITE3_VALUE_BYTES16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_double {
        __SQLITE3_VALUE_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_int {
        __SQLITE3_VALUE_INT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_int64 {
        __SQLITE3_VALUE_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_numeric_type {
        __SQLITE3_VALUE_NUMERIC_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_text {
        __SQLITE3_VALUE_TEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_text16 {
        __SQLITE3_VALUE_TEXT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_text16be {
        __SQLITE3_VALUE_TEXT16BE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_text16le {
        __SQLITE3_VALUE_TEXT16LE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_type {
        __SQLITE3_VALUE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).overload_function {
        __SQLITE3_OVERLOAD_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare_v2 {
        __SQLITE3_PREPARE_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare16_v2 {
        __SQLITE3_PREPARE16_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).clear_bindings {
        __SQLITE3_CLEAR_BINDINGS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_module_v2 {
        __SQLITE3_CREATE_MODULE_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_zeroblob {
        __SQLITE3_BIND_ZEROBLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_bytes {
        __SQLITE3_BLOB_BYTES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_close {
        __SQLITE3_BLOB_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_open {
        __SQLITE3_BLOB_OPEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_read {
        __SQLITE3_BLOB_READ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_write {
        __SQLITE3_BLOB_WRITE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_collation_v2 {
        __SQLITE3_CREATE_COLLATION_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).file_control {
        __SQLITE3_FILE_CONTROL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).memory_highwater {
        __SQLITE3_MEMORY_HIGHWATER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).memory_used {
        __SQLITE3_MEMORY_USED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).mutex_alloc {
        __SQLITE3_MUTEX_ALLOC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).mutex_enter {
        __SQLITE3_MUTEX_ENTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).mutex_free {
        __SQLITE3_MUTEX_FREE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).mutex_leave {
        __SQLITE3_MUTEX_LEAVE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).mutex_try {
        __SQLITE3_MUTEX_TRY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).open_v2 {
        __SQLITE3_OPEN_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).release_memory {
        __SQLITE3_RELEASE_MEMORY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_error_nomem {
        __SQLITE3_RESULT_ERROR_NOMEM
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_error_toobig {
        __SQLITE3_RESULT_ERROR_TOOBIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).sleep {
        __SQLITE3_SLEEP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).soft_heap_limit {
        __SQLITE3_SOFT_HEAP_LIMIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vfs_find {
        __SQLITE3_VFS_FIND
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vfs_register {
        __SQLITE3_VFS_REGISTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vfs_unregister {
        __SQLITE3_VFS_UNREGISTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).xthreadsafe {
        __SQLITE3_THREADSAFE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_zeroblob {
        __SQLITE3_RESULT_ZEROBLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_error_code {
        __SQLITE3_RESULT_ERROR_CODE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).randomness {
        __SQLITE3_RANDOMNESS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).context_db_handle {
        __SQLITE3_CONTEXT_DB_HANDLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).extended_result_codes {
        __SQLITE3_EXTENDED_RESULT_CODES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).limit {
        __SQLITE3_LIMIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).next_stmt {
        __SQLITE3_NEXT_STMT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).sql {
        __SQLITE3_SQL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).status {
        __SQLITE3_STATUS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).backup_finish {
        __SQLITE3_BACKUP_FINISH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).backup_init {
        __SQLITE3_BACKUP_INIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).backup_pagecount {
        __SQLITE3_BACKUP_PAGECOUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).backup_remaining {
        __SQLITE3_BACKUP_REMAINING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).backup_step {
        __SQLITE3_BACKUP_STEP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).compileoption_get {
        __SQLITE3_COMPILEOPTION_GET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).compileoption_used {
        __SQLITE3_COMPILEOPTION_USED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_function_v2 {
        __SQLITE3_CREATE_FUNCTION_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_config {
        __SQLITE3_DB_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_mutex {
        __SQLITE3_DB_MUTEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_status {
        __SQLITE3_DB_STATUS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).extended_errcode {
        __SQLITE3_EXTENDED_ERRCODE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).log {
        __SQLITE3_LOG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).soft_heap_limit64 {
        __SQLITE3_SOFT_HEAP_LIMIT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).sourceid {
        __SQLITE3_SOURCEID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stmt_status {
        __SQLITE3_STMT_STATUS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).strnicmp {
        __SQLITE3_STRNICMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).unlock_notify {
        __SQLITE3_UNLOCK_NOTIFY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).wal_autocheckpoint {
        __SQLITE3_WAL_AUTOCHECKPOINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).wal_checkpoint {
        __SQLITE3_WAL_CHECKPOINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).wal_hook {
        __SQLITE3_WAL_HOOK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).blob_reopen {
        __SQLITE3_BLOB_REOPEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_config {
        __SQLITE3_VTAB_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_on_conflict {
        __SQLITE3_VTAB_ON_CONFLICT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).close_v2 {
        __SQLITE3_CLOSE_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_filename {
        __SQLITE3_DB_FILENAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_readonly {
        __SQLITE3_DB_READONLY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_release_memory {
        __SQLITE3_DB_RELEASE_MEMORY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).errstr {
        __SQLITE3_ERRSTR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stmt_busy {
        __SQLITE3_STMT_BUSY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stmt_readonly {
        __SQLITE3_STMT_READONLY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stricmp {
        __SQLITE3_STRICMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).uri_boolean {
        __SQLITE3_URI_BOOLEAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).uri_int64 {
        __SQLITE3_URI_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).uri_parameter {
        __SQLITE3_URI_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).wal_checkpoint_v2 {
        __SQLITE3_WAL_CHECKPOINT_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).auto_extension {
        __SQLITE3_AUTO_EXTENSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_blob64 {
        __SQLITE3_BIND_BLOB64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_text64 {
        __SQLITE3_BIND_TEXT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).cancel_auto_extension {
        __SQLITE3_CANCEL_AUTO_EXTENSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).load_extension {
        __SQLITE3_LOAD_EXTENSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).malloc64 {
        __SQLITE3_MALLOC64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).msize {
        __SQLITE3_MSIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).realloc64 {
        __SQLITE3_REALLOC64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).reset_auto_extension {
        __SQLITE3_RESET_AUTO_EXTENSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_blob64 {
        __SQLITE3_RESULT_BLOB64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_text64 {
        __SQLITE3_RESULT_TEXT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).strglob {
        __SQLITE3_STRGLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_dup {
        __SQLITE3_VALUE_DUP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_free {
        __SQLITE3_VALUE_FREE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_zeroblob64 {
        __SQLITE3_RESULT_ZEROBLOB64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_zeroblob64 {
        __SQLITE3_BIND_ZEROBLOB64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_subtype {
        __SQLITE3_VALUE_SUBTYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_subtype {
        __SQLITE3_RESULT_SUBTYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).status64 {
        __SQLITE3_STATUS64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).strlike {
        __SQLITE3_STRLIKE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_cacheflush {
        __SQLITE3_DB_CACHEFLUSH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).system_errno {
        __SQLITE3_SYSTEM_ERRNO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).trace_v2 {
        __SQLITE3_TRACE_V2
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).expanded_sql {
        __SQLITE3_EXPANDED_SQL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).set_last_insert_rowid {
        __SQLITE3_SET_LAST_INSERT_ROWID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare_v3 {
        __SQLITE3_PREPARE_V3
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).prepare16_v3 {
        __SQLITE3_PREPARE16_V3
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).bind_pointer {
        __SQLITE3_BIND_POINTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).result_pointer {
        __SQLITE3_RESULT_POINTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_pointer {
        __SQLITE3_VALUE_POINTER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_nochange {
        __SQLITE3_VTAB_NOCHANGE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_nochange {
        __SQLITE3_VALUE_NOCHANGE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_collation {
        __SQLITE3_VTAB_COLLATION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).keyword_count {
        __SQLITE3_KEYWORD_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).keyword_name {
        __SQLITE3_KEYWORD_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).keyword_check {
        __SQLITE3_KEYWORD_CHECK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_new {
        __SQLITE3_STR_NEW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_finish {
        __SQLITE3_STR_FINISH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_append {
        __SQLITE3_STR_APPEND
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_appendall {
        __SQLITE3_STR_APPENDALL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_appendchar {
        __SQLITE3_STR_APPENDCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_reset {
        __SQLITE3_STR_RESET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_errcode {
        __SQLITE3_STR_ERRCODE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_length {
        __SQLITE3_STR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).str_value {
        __SQLITE3_STR_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_window_function {
        __SQLITE3_CREATE_WINDOW_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).normalized_sql {
        __SQLITE3_NORMALIZED_SQL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stmt_isexplain {
        __SQLITE3_STMT_ISEXPLAIN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_frombind {
        __SQLITE3_VALUE_FROMBIND
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).drop_modules {
        __SQLITE3_DROP_MODULES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).hard_heap_limit64 {
        __SQLITE3_HARD_HEAP_LIMIT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).uri_key {
        __SQLITE3_URI_KEY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).filename_database {
        __SQLITE3_FILENAME_DATABASE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).filename_journal {
        __SQLITE3_FILENAME_JOURNAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).filename_wal {
        __SQLITE3_FILENAME_WAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).create_filename {
        __SQLITE3_CREATE_FILENAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).free_filename {
        __SQLITE3_FREE_FILENAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).database_file_object {
        __SQLITE3_DATABASE_FILE_OBJECT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).txn_state {
        __SQLITE3_TXN_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).changes64 {
        __SQLITE3_CHANGES64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).total_changes64 {
        __SQLITE3_TOTAL_CHANGES64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).autovacuum_pages {
        __SQLITE3_AUTOVACUUM_PAGES
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).error_offset {
        __SQLITE3_ERROR_OFFSET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_rhs_value {
        __SQLITE3_VTAB_RHS_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_distinct {
        __SQLITE3_VTAB_DISTINCT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_in {
        __SQLITE3_VTAB_IN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_in_first {
        __SQLITE3_VTAB_IN_FIRST
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).vtab_in_next {
        __SQLITE3_VTAB_IN_NEXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).deserialize {
        __SQLITE3_DESERIALIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).serialize {
        __SQLITE3_SERIALIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).db_name {
        __SQLITE3_DB_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).value_encoding {
        __SQLITE3_VALUE_ENCODING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).is_interrupted {
        __SQLITE3_IS_INTERRUPTED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).stmt_explain {
        __SQLITE3_STMT_EXPLAIN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).get_clientdata {
        __SQLITE3_GET_CLIENTDATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).set_clientdata {
        __SQLITE3_SET_CLIENTDATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    Ok(())
}

